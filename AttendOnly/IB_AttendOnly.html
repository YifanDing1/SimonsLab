<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inattentional Blindness Experiment - Circles Only</title>
    <style>
        /* STYLING */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        #experimentContainer {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #canvasContainer {
            text-align: center;
            min-height: 600px;
        }

        #canvas {
            display: block;
            margin: 20px auto;
            border: 2px solid #333;
            background-color: #7676A7;
        }

        button {
            font-size: 18px;
            padding: 10px 20px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        input[type="number"] {
            font-size: 16px;
            padding: 5px;
            width: 80px;
            margin: 5px;
        }

        input[type="text"] {
            font-size: 16px;
            padding: 5px;
            width: 300px;
            margin: 5px;
        }

        .hidden {
            display: none !important;
        }

        #instructions {
            text-align: center;
            margin: 20px;
            font-size: 18px;
            line-height: 1.5;
            min-height: 200px;
            padding: 40px;
        }

        .response-section {
            background: #f9f9f9;
            padding: 40px;
            border-radius: 5px;
            margin: 10px auto;
            min-height: 300px;
            max-width: 600px;
            text-align: center;
        }

        .choice-button {
            display: inline-block;
            margin: 10px;
            padding: 15px 30px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            background-color: white;
        }

        .choice-button:hover {
            border-color: #4CAF50;
            background-color: #f0f0f0;
        }

        .choice-button.selected {
            border-color: #4CAF50;
            background-color: #e8f5e9;
        }

        .screen {
            min-height: 500px;
        }
    </style>
</head>
<body>
    <div id="experimentContainer">
        <!-- Hidden form for data submission -->
        <form id="task_data" name="task_data" action="data.php" method="post">
            <input type="hidden" name="study_name" value="">
            <input type="hidden" name="subject_code" value="">
            <input type="hidden" name="start_time" value="">
            <input type="hidden" name="end_time" value="">
            <input type="hidden" name="duration" value="">
            <input type="hidden" name="background_color" value="">
            <input type="hidden" name="attended_color" value="">
            <input type="hidden" name="unexpected_object_color" value="">
            <input type="hidden" name="unexpected_object_shape" value="">
            <input type="hidden" name="unexpected_object_direction" value="">
            <!-- Trial 1 (Practice 1) -->
            <input type="hidden" name="trial1_bounces" value="">
            <input type="hidden" name="trial1_count" value="">
            <input type="hidden" name="trial1_accuracy" value="">
            <!-- Trial 2 (Practice 2) -->
            <input type="hidden" name="trial2_bounces" value="">
            <input type="hidden" name="trial2_count" value="">
            <input type="hidden" name="trial2_accuracy" value="">
            <!-- Trial 3 (Critical) -->
            <input type="hidden" name="trial3_bounces" value="">
            <input type="hidden" name="trial3_count" value="">
            <input type="hidden" name="trial3_accuracy" value="">
            <input type="hidden" name="trial3_noticed" value="">
            <input type="hidden" name="trial3_shape_choice" value="">
            <!-- Trial 4 (Divided) -->
            <input type="hidden" name="trial4_bounces" value="">
            <input type="hidden" name="trial4_count" value="">
            <input type="hidden" name="trial4_accuracy" value="">
            <input type="hidden" name="trial4_noticed" value="">
            <input type="hidden" name="trial4_shape_choice" value="">
            <!-- Accuracy summary -->
            <input type="hidden" name="practice_accuracy_avg" value="">
            <!-- Playback questions -->
            <input type="hidden" name="run_smoothly" value="">
            <input type="hidden" name="glitches_description" value="">
        </form>

        <!-- Instructions Screen -->
        <div id="instructionScreen" class="screen">
            <div id="instructions">
                <p>Loading...</p>
            </div>
        </div>

        <!-- Canvas Screen (for animation) -->
        <div id="canvasScreen" class="screen hidden">
            <div id="canvasContainer">
                <canvas id="canvas" width="666" height="546"></canvas>
            </div>
        </div>

        <!-- Response Input Screen -->
        <div id="responseScreen" class="screen hidden">
            <div id="responseSection" class="response-section">
                <h2 id="responsePrompt">Enter your count:</h2>
                <div id="singleCount">
                    <label>Total bounces: </label>
                    <input type="number" id="countInput" min="0" max="100">
                    <br><br>
                    <button id="submitCount" onclick="experiment.submitResponse()">Submit</button>
                </div>
            </div>
        </div>

        <!-- Yes/No Question Screen -->
        <div id="yesNoScreen" class="screen hidden">
            <div id="yesNoSection" class="response-section">
                <h2 id="yesNoQuestion">Did you notice anything unusual?</h2>
                <button class="yesno-btn" onclick="experiment.submitYesNo('Yes')">Yes</button>
                <button class="yesno-btn" onclick="experiment.submitYesNo('No')">No</button>
            </div>
        </div>

        <!-- Shape Selection Screen -->
        <div id="shapeScreen" class="screen hidden">
            <div id="shapeSection" class="response-section">
                <h2>There actually was an extra object. If you saw it, please select the shape you saw. If you didn't see it, please guess.</h2>
                <div style="display: flex; justify-content: center; gap: 20px; margin: 20px 0;">
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('cross')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="0" y1="50" x2="100" y2="50" style="stroke:#777777; stroke-width:10"/>
                            <line x1="50" y1="0" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('Z')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="10" y1="10" x2="90" y2="10" style="stroke:#777777; stroke-width:10"/>
                            <line x1="87" y1="9" x2="13.3" y2="90" style="stroke:#777777; stroke-width:10"/>
                            <line x1="10" y1="90" x2="90" y2="90" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('L')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="25" y1="10" x2="25" y2="90" style="stroke:#777777; stroke-width:10"/>
                            <line x1="20" y1="90" x2="75" y2="90" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('T')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="10" y1="20" x2="90" y2="20" style="stroke:#777777; stroke-width:10"/>
                            <line x1="50" y1="20" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                </div>
                <button onclick="experiment.submitShapeChoice()">Submit Choice</button>
            </div>
        </div>

        <!-- Playback Questions Screen -->
        <div id="playbackScreen" class="screen hidden">
            <div id="playbackSection" class="response-section">
                <h2 id="playbackQuestion">Did the animation play smoothly?</h2>
                <button class="playback-btn" onclick="experiment.submitPlayback('Yes')">Yes</button>
                <button class="playback-btn" onclick="experiment.submitPlayback('No')">No</button>
            </div>
        </div>

        <!-- Glitches Description Screen -->
        <div id="glitchesScreen" class="screen hidden">
            <div id="glitchesSection" class="response-section">
                <h2>Please describe the playback issues you experienced:</h2>
                <input type="text" id="glitchesInput" placeholder="Describe any issues...">
                <br><br>
                <button onclick="experiment.submitGlitches()">Submit</button>
            </div>
        </div>

        <!-- Final Screen -->
        <div id="finalScreen" class="screen hidden">
            <div id="finalSection" class="response-section">
                <h2>Thank you for completing the task!</h2>
                <p>Click 'Continue' to go back to Prolific.</p>
                <button id="finalSubmit" onclick="experiment.submitData()">Continue</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // EXPERIMENT CONTROLLER
        // 4 circles that are randomly either all white or all black
        // ============================================================
        const experiment = {
            // Configuration
            config: {
                numObjects: 4,
                trialDuration: 19000,        // 19 seconds like original
                unexpectedObjectStart: 5000, // 5 seconds like original
                canvasWidth: 666,
                canvasHeight: 546,
                objectSize: 44,
                backgroundColor: '#7676A7'
            },

            // State tracking
            state: {
                currentTrial: 0,
                trialSequence: ['practice', 'practice', 'critical', 'divided'],
                currentPhase: 'instructions',
                isRunning: false,
                attendedColor: null  // Will be randomly assigned: 'white' or 'black'
            },

            // Timing
            timing: {
                startTime: null,
                endTime: null
            },

            // Data collection
            data: {
                studyName: 'pilot2',
                subjectCode: null,
                startTime: '',
                endTime: '',
                duration: 0,
                unexpectedObjectColor: null,
                unexpectedObjectShape: null,
                unexpectedObjectDirection: null,
                trials: {
                    bounces: [],
                    counts: [],
                    accuracy: []
                },
                responses: {
                    noticed: [null, null],
                    shapeChoice: [null, null]
                },
                practiceAccuracyAvg: null,
                runSmoothly: null,
                glitchesDescription: ''
            },

            // Initialize
            init() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.objects = [];
                this.unexpectedObject = null;
                this.lastFrameTime = null; // For delta time calculation

                // Get subject_code from URL
                const urlParams = new URLSearchParams(window.location.search);
                this.data.subjectCode = urlParams.get('subject_code') || 'test_subject';
                console.log("Subject code:", this.data.subjectCode);

                // Randomly assign attended color: white or black
                this.state.attendedColor = Math.random() < 0.5 ? 'white' : 'black';
                console.log("Attended color:", this.state.attendedColor);

                // Record start time
                this.timing.startTime = new Date();
                this.data.startTime = this.formatDate(this.timing.startTime);

                console.log("Experiment initialized - 4", this.state.attendedColor, "circles");
                console.log("Using delta-time animation for consistent speed across all devices");
            },

            // Format date for database (CST timezone)
            formatDate(date) {
                const options = {
                    timeZone: 'America/Chicago',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                };
                const cstDateString = new Intl.DateTimeFormat('en-US', options).format(date);
                const [datePart, timePart] = cstDateString.split(', ');
                const [month, day, year] = datePart.split('/');
                return `${year}/${month}/${day} ${timePart}`;
            },

            // Start the experiment (called from first instruction button)
            start() {
                this.startTrial();
            },

            // Show only one screen
            showScreen(screenId) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.add('hidden');
                });
                document.getElementById(screenId).classList.remove('hidden');
            },

            // Get color name in uppercase for instructions
            getColorText() {
                return this.state.attendedColor.toUpperCase();
            },

            // Show instructions based on trial type
            showInstructions() {
                this.showScreen('instructionScreen');
                const instructions = document.getElementById('instructions');
                const trialType = this.state.trialSequence[this.state.currentTrial];
                const colorText = this.getColorText();

                let message = "";
                if (this.state.currentTrial === 0) {
                    // Initial instructions
                    message = `<p>In this task, 4 ${colorText.toLowerCase()} circles will appear inside a colored rectangle.
                              After a moment, they will begin moving and bouncing off the sides of the rectangle.</p>
                              <p>Please count the total number of times the ${colorText} CIRCLES bounce off
                              the sides of the rectangle.</p>
                              <p>You will be asked to report your total count.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'practice') {
                    message = `<p>On the next screen, you will do the same task. Again, please count the total
                              number of times the ${colorText} CIRCLES bounce off the sides of the rectangle.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'critical') {
                    message = `<p>On the next screen, you will do the same task. Again, please count the total
                              number of times the ${colorText} CIRCLES bounce off the sides of the rectangle.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'divided') {
                    message = `<p>On the next screen, you will do the same task. Again, please count the total
                              number of times the ${colorText} CIRCLES bounce off the sides of the rectangle.</p>
                              <p><strong>NEW REQUIREMENT:</strong> This time, you should <strong>also look</strong>
                              for the presence of an extra object.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                }

                instructions.innerHTML = message;
            },

            // Start a trial
            startTrial() {
                const trialType = this.state.trialSequence[this.state.currentTrial];
                console.log("Starting trial:", this.state.currentTrial + 1, "Type:", trialType);

                this.showScreen('canvasScreen');
                this.createObjects();
                this.state.isRunning = true;
                this.lastFrameTime = null; // Reset for delta time calculation

                // Set up unexpected object for critical/divided trials
                if (trialType === 'critical' || trialType === 'divided') {
                    setTimeout(() => {
                        this.addUnexpectedObject();
                    }, this.config.unexpectedObjectStart);
                }

                // Start animation with requestAnimationFrame timestamp
                requestAnimationFrame((time) => this.animate(time));

                // End trial after duration
                setTimeout(() => {
                    this.endTrial();
                }, this.config.trialDuration);
            },

            // Create moving objects - all same color (randomly white or black)
            createObjects() {
                this.objects = [];

                for (let i = 0; i < this.config.numObjects; i++) {
                    const margin = this.config.objectSize;
                    // Velocity scaled for 60fps to match original 37fps speed
                    const speed = Math.random() * 1.0 + 1.2;
                    const xDir = Math.random() < 0.5 ? 1 : -1;
                    const yDir = Math.random() < 0.5 ? 1 : -1;

                    this.objects.push({
                        x: Math.random() * (this.config.canvasWidth - margin * 2) + margin,
                        y: Math.random() * (this.config.canvasHeight - margin * 2) + margin,
                        vx: speed * xDir,
                        vy: speed * yDir,
                        color: this.state.attendedColor,  // Use the randomly assigned color
                        size: this.config.objectSize,
                        bounces: 0
                    });
                }
            },

            // Add unexpected object - gray cross
            addUnexpectedObject() {
                const trialType = this.state.trialSequence[this.state.currentTrial];

                // For critical trial, randomly choose direction
                if (trialType === 'critical') {
                    this.data.unexpectedObjectColor = '#777777'; // Gray
                    this.data.unexpectedObjectShape = 'cross';
                    this.data.unexpectedObjectDirection = Math.random() < 0.5 ? 'LeftToRight' : 'RightToLeft';
                }
                // For divided trial, use same direction as critical

                const direction = this.data.unexpectedObjectDirection === 'LeftToRight' ? 1 : -1;
                const startX = direction === 1 ? -30 : this.config.canvasWidth + 30;
                const speed = 1.2;

                this.unexpectedObject = {
                    x: startX,
                    y: this.config.canvasHeight / 2,
                    vx: speed * direction,
                    vy: 0,
                    color: this.data.unexpectedObjectColor,
                    size: this.config.objectSize,
                    isUnexpected: true
                };

                console.log("Unexpected object: gray cross",
                           "Direction:", this.data.unexpectedObjectDirection);
            },

            // Animation loop with delta time for consistent speed across all devices
            animate(currentTime) {
                if (!this.state.isRunning) return;

                // Calculate delta time (time since last frame in ms)
                if (!this.lastFrameTime) {
                    this.lastFrameTime = currentTime;
                }
                const deltaTime = currentTime - this.lastFrameTime;
                this.lastFrameTime = currentTime;

                // Target 60fps - calculate time multiplier
                // If running at 144fps, deltaTime ~7ms, multiplier ~0.42
                // If running at 60fps, deltaTime ~16.67ms, multiplier ~1.0
                // If running at 30fps, deltaTime ~33ms, multiplier ~2.0
                const targetFrameTime = 1000 / 60; // 16.67ms for 60fps
                const timeMultiplier = deltaTime / targetFrameTime;

                // Clear canvas
                this.ctx.fillStyle = this.config.backgroundColor;
                this.ctx.fillRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);

                // Draw unexpected object FIRST (so it appears behind circles)
                if (this.unexpectedObject) {
                    this.updateUnexpectedObject(timeMultiplier);
                }
                if (this.unexpectedObject) {
                    this.drawCross(this.unexpectedObject);
                }

                // Update and draw regular objects (on top of UO)
                this.objects.forEach(obj => {
                    this.updateObject(obj, timeMultiplier);
                    this.drawObject(obj);
                });

                // Continue animation
                requestAnimationFrame((time) => this.animate(time));
            },

            // Update object position with time-based movement
            updateObject(obj, timeMultiplier) {
                // Apply time multiplier for consistent speed across all frame rates
                obj.x += obj.vx * timeMultiplier;
                obj.y += obj.vy * timeMultiplier;

                const radius = obj.size / 2;

                // Wall collisions
                if (obj.x - radius <= 0 || obj.x + radius >= this.config.canvasWidth) {
                    obj.vx *= -1;
                    if (obj.x - radius <= 0) obj.x = radius;
                    if (obj.x + radius >= this.config.canvasWidth) obj.x = this.config.canvasWidth - radius;
                    if (!obj.isUnexpected) obj.bounces++;
                }

                if (obj.y - radius <= 0 || obj.y + radius >= this.config.canvasHeight) {
                    obj.vy *= -1;
                    if (obj.y - radius <= 0) obj.y = radius;
                    if (obj.y + radius >= this.config.canvasHeight) obj.y = this.config.canvasHeight - radius;
                    if (!obj.isUnexpected) obj.bounces++;
                }
            },

            // Update unexpected object with time-based movement
            updateUnexpectedObject(timeMultiplier) {
                if (this.unexpectedObject) {
                    this.unexpectedObject.x += this.unexpectedObject.vx * timeMultiplier;

                    // Remove when off screen
                    if (this.unexpectedObject.vx > 0 && this.unexpectedObject.x > this.config.canvasWidth + 30) {
                        this.unexpectedObject = null;
                    } else if (this.unexpectedObject.vx < 0 && this.unexpectedObject.x < -30) {
                        this.unexpectedObject = null;
                    }
                }
            },

            // Draw circle object
            drawObject(obj) {
                this.ctx.fillStyle = obj.color;
                this.ctx.beginPath();
                this.ctx.arc(obj.x, obj.y, obj.size / 2, 0, Math.PI * 2);
                this.ctx.fill();
            },

            // Draw cross (for unexpected object)
            drawCross(obj) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.strokeStyle = obj.color;
                this.ctx.lineWidth = obj.size / 4;
                // Draw horizontal line
                this.ctx.moveTo(obj.x - obj.size / 2, obj.y);
                this.ctx.lineTo(obj.x + obj.size / 2, obj.y);
                // Draw vertical line
                this.ctx.moveTo(obj.x, obj.y - obj.size / 2);
                this.ctx.lineTo(obj.x, obj.y + obj.size / 2);
                this.ctx.stroke();
                this.ctx.restore();
            },

            // End trial
            endTrial() {
                this.state.isRunning = false;
                this.unexpectedObject = null;

                // Calculate bounces
                let totalBounces = 0;
                this.objects.forEach(obj => {
                    totalBounces += obj.bounces;
                });

                this.data.trials.bounces.push(totalBounces);
                console.log("Trial", this.state.currentTrial + 1, "- Actual bounces:", totalBounces);

                this.showResponseInput();
            },

            // Show response input
            showResponseInput() {
                this.showScreen('responseScreen');
                const colorText = this.getColorText();
                document.getElementById('responsePrompt').textContent =
                    `In the box below, please enter the total number of times the ${colorText} CIRCLES bounced off the edges of the rectangle.`;
                document.getElementById('countInput').value = '';
                document.getElementById('countInput').focus();
            },

            // Submit counting response
            submitResponse() {
                const count = parseInt(document.getElementById('countInput').value) || 0;
                this.data.trials.counts.push(count);

                // Calculate accuracy
                const trialIndex = this.data.trials.counts.length - 1;
                const actual = this.data.trials.bounces[trialIndex];
                const percentError = Math.abs(count - actual) / actual * 100;
                const accuracy = Math.max(0, Math.min(100, 100 - percentError));
                this.data.trials.accuracy.push(parseFloat(accuracy.toFixed(2)));

                console.log("Count submitted:", count, "Actual:", actual, "Accuracy:", accuracy.toFixed(2) + "%");

                const trialType = this.state.trialSequence[this.state.currentTrial];

                if (trialType === 'critical') {
                    this.showNoticeQuestion();
                } else if (trialType === 'divided') {
                    this.showNoticeQuestion();
                } else {
                    this.nextTrial();
                }
            },

            // Show notice question
            showNoticeQuestion() {
                this.showScreen('yesNoScreen');
                const trialType = this.state.trialSequence[this.state.currentTrial];

                if (trialType === 'critical') {
                    document.getElementById('yesNoQuestion').textContent =
                        "Did you notice anything extra during the last counting trial that wasn't there in the previous trials?";
                } else {
                    document.getElementById('yesNoQuestion').textContent =
                        "Did you notice an extra object on that trial?";
                }
            },

            // Submit yes/no response
            submitYesNo(answer) {
                const trialType = this.state.trialSequence[this.state.currentTrial];
                const responseIndex = trialType === 'critical' ? 0 : 1;
                this.data.responses.noticed[responseIndex] = answer;

                console.log("Noticed:", answer, "Trial type:", trialType);

                this.showShapeSelection();
            },

            // Show shape selection
            showShapeSelection() {
                this.showScreen('shapeScreen');
                // Clear previous selection
                document.querySelectorAll('#shapeSection .shape-choice').forEach(el => {
                    el.classList.remove('selected');
                });
                this.selectedShape = null;
            },

            // Select a shape
            selectShape(shape) {
                document.querySelectorAll('#shapeSection .shape-choice').forEach(el => {
                    el.classList.remove('selected');
                });
                event.currentTarget.classList.add('selected');
                this.selectedShape = shape;
            },

            // Submit shape choice
            submitShapeChoice() {
                if (!this.selectedShape) {
                    alert("Please select a shape");
                    return;
                }

                const trialType = this.state.trialSequence[this.state.currentTrial];
                const responseIndex = trialType === 'critical' ? 0 : 1;
                this.data.responses.shapeChoice[responseIndex] = this.selectedShape;

                console.log("Shape choice:", this.selectedShape);

                this.nextTrial();
            },

            // Move to next trial
            nextTrial() {
                this.state.currentTrial++;

                if (this.state.currentTrial < this.state.trialSequence.length) {
                    this.showInstructions();
                } else {
                    this.showPlaybackQuestion();
                }
            },

            // Show playback question
            showPlaybackQuestion() {
                // Calculate practice accuracy average first
                const practiceAcc1 = this.data.trials.accuracy[0] || 0;
                const practiceAcc2 = this.data.trials.accuracy[1] || 0;
                this.data.practiceAccuracyAvg = parseFloat(((practiceAcc1 + practiceAcc2) / 2).toFixed(2));

                this.showScreen('playbackScreen');
                document.getElementById('playbackQuestion').textContent =
                    "Did the animation play smoothly, with no obvious lagging or freezing?";
            },

            // Submit playback response
            submitPlayback(answer) {
                this.data.runSmoothly = answer;
                console.log("Run smoothly:", answer);

                if (answer === 'No') {
                    this.showGlitchesScreen();
                } else {
                    this.showFinalScreen();
                }
            },

            // Show glitches description screen
            showGlitchesScreen() {
                this.showScreen('glitchesScreen');
                document.getElementById('glitchesInput').value = '';
            },

            // Submit glitches description
            submitGlitches() {
                this.data.glitchesDescription = document.getElementById('glitchesInput').value;
                console.log("Glitches description:", this.data.glitchesDescription);
                this.showFinalScreen();
            },

            // Show final screen
            showFinalScreen() {
                this.showScreen('finalScreen');
            },

            // Submit all data
            submitData() {
                // Record end time
                this.timing.endTime = new Date();
                this.data.endTime = this.formatDate(this.timing.endTime);
                this.data.duration = Math.round((this.timing.endTime - this.timing.startTime) / 1000);

                // Fill in form fields
                const form = document.getElementById('task_data');
                form.study_name.value = this.data.studyName;
                form.subject_code.value = this.data.subjectCode;
                form.start_time.value = this.data.startTime;
                form.end_time.value = this.data.endTime;
                form.duration.value = this.data.duration;
                form.background_color.value = this.config.backgroundColor;
                form.attended_color.value = this.state.attendedColor;
                form.unexpected_object_color.value = this.data.unexpectedObjectColor || '';
                form.unexpected_object_shape.value = this.data.unexpectedObjectShape || '';
                form.unexpected_object_direction.value = this.data.unexpectedObjectDirection || '';

                // Trial 1 (Practice 1)
                form.trial1_bounces.value = this.data.trials.bounces[0] || '';
                form.trial1_count.value = this.data.trials.counts[0] || '';
                form.trial1_accuracy.value = this.data.trials.accuracy[0] || '';

                // Trial 2 (Practice 2)
                form.trial2_bounces.value = this.data.trials.bounces[1] || '';
                form.trial2_count.value = this.data.trials.counts[1] || '';
                form.trial2_accuracy.value = this.data.trials.accuracy[1] || '';

                // Trial 3 (Critical)
                form.trial3_bounces.value = this.data.trials.bounces[2] || '';
                form.trial3_count.value = this.data.trials.counts[2] || '';
                form.trial3_accuracy.value = this.data.trials.accuracy[2] || '';
                form.trial3_noticed.value = this.data.responses.noticed[0] || '';
                form.trial3_shape_choice.value = this.data.responses.shapeChoice[0] || '';

                // Trial 4 (Divided)
                form.trial4_bounces.value = this.data.trials.bounces[3] || '';
                form.trial4_count.value = this.data.trials.counts[3] || '';
                form.trial4_accuracy.value = this.data.trials.accuracy[3] || '';
                form.trial4_noticed.value = this.data.responses.noticed[1] || '';
                form.trial4_shape_choice.value = this.data.responses.shapeChoice[1] || '';

                // Accuracy summary
                form.practice_accuracy_avg.value = this.data.practiceAccuracyAvg || '';

                // Playback
                form.run_smoothly.value = this.data.runSmoothly || '';
                form.glitches_description.value = this.data.glitchesDescription || '';

                // Log all data for debugging
                console.log("=== FINAL DATA ===");
                console.log("Study name:", this.data.studyName);
                console.log("Subject:", this.data.subjectCode);
                console.log("Duration:", this.data.duration, "seconds");
                console.log("Attended color:", this.state.attendedColor);
                console.log("Bounces:", this.data.trials.bounces);
                console.log("Counts:", this.data.trials.counts);
                console.log("Accuracy:", this.data.trials.accuracy);
                console.log("Practice Avg:", this.data.practiceAccuracyAvg);
                console.log("UO Color:", this.data.unexpectedObjectColor);
                console.log("UO Shape:", this.data.unexpectedObjectShape);
                console.log("UO Direction:", this.data.unexpectedObjectDirection);
                console.log("Noticed:", this.data.responses.noticed);
                console.log("Shape Choice:", this.data.responses.shapeChoice);
                console.log("==================");

                // Create data object for submission
                const formData = new FormData(form);
                const dataObject = {};
                formData.forEach((value, key) => {
                    dataObject[key] = value;
                });

                const json = JSON.stringify(dataObject);
                console.log("JSON being sent:", json);

                // Send data via XMLHttpRequest
                const xhr = new XMLHttpRequest();
                xhr.open("POST", "data.php", true);
                xhr.setRequestHeader("Content-Type", "application/json");
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        console.log("Server response:", xhr.responseText);
                        if (xhr.status === 200) {
                            // Redirect to Prolific
                            window.location.href = 'https://app.prolific.com/submissions/complete?cc=C1QBLCRQ';
                            console.log("Data submitted successfully.");
                        } else {
                            console.error("Error submitting data");
                        }
                    }
                };
                xhr.send(json);
            }
        };

        // ============================================================
        // INITIALIZATION
        // ============================================================
        window.onload = function() {
            console.log("Page loaded - Experiment ready!");
            // Initialize and show first instructions
            experiment.init();
            experiment.showInstructions();
        };
    </script>
</body>
</html>