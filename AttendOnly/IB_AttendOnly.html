<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inattentional Blindness Experiment - Pilot 8: Attend+Ignore Jitter Distractors</title>
    <style>
        /* STYLING */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        #experimentContainer {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #canvasContainer {
            text-align: center;
            min-height: 600px;
        }

        #canvas {
            display: block;
            margin: 20px auto;
            border: 2px solid #333;
            background-color: #7676A7;
        }

        button {
            font-size: 18px;
            padding: 10px 20px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        input[type="number"] {
            font-size: 16px;
            padding: 5px;
            width: 80px;
            margin: 5px;
        }

        input[type="text"] {
            font-size: 16px;
            padding: 5px;
            width: 300px;
            margin: 5px;
        }

        .hidden {
            display: none !important;
        }

        #instructions {
            text-align: center;
            margin: 20px;
            font-size: 18px;
            line-height: 1.5;
            min-height: 200px;
            padding: 40px;
        }

        .response-section {
            background: #f9f9f9;
            padding: 40px;
            border-radius: 5px;
            margin: 10px auto;
            min-height: 300px;
            max-width: 600px;
            text-align: center;
        }

        .choice-button {
            display: inline-block;
            margin: 10px;
            padding: 15px 30px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            background-color: white;
        }

        .choice-button:hover {
            border-color: #4CAF50;
            background-color: #f0f0f0;
        }

        .choice-button.selected {
            border-color: #4CAF50;
            background-color: #e8f5e9;
        }

        .screen {
            min-height: 500px;
        }
    </style>
</head>
<body>
    <div id="experimentContainer">
        <!-- Hidden form for data submission -->
        <form id="task_data" name="task_data" action="data.php" method="post">
            <input type="hidden" name="study_name" value="">
            <input type="hidden" name="subject_code" value="">
            <input type="hidden" name="start_time" value="">
            <input type="hidden" name="end_time" value="">
            <input type="hidden" name="duration" value="">
            <input type="hidden" name="background_color" value="">
            <input type="hidden" name="attended_color" value="">
            <input type="hidden" name="bounce_angle_variation" value="">
            <input type="hidden" name="min_angle_from_wall" value="">
            <input type="hidden" name="perturbation_interval_min" value="">
            <input type="hidden" name="perturbation_interval_max" value="">
            <input type="hidden" name="perturbation_amount" value="">
            <input type="hidden" name="speed_min" value="">
            <input type="hidden" name="speed_max" value="">
            <input type="hidden" name="unexpected_object_speed" value="">
            <input type="hidden" name="unexpected_object_color" value="">
            <input type="hidden" name="unexpected_object_shape" value="">
            <input type="hidden" name="unexpected_object_direction" value="">
            <!-- Static distractor positions -->
            <input type="hidden" name="num_distractors" value="">
            <input type="hidden" name="distractor_color" value="">
            <input type="hidden" name="distractor_positions" value="">
            <input type="hidden" name="distractor_motion" value="">
            <!-- Trial 1 (Practice 1) -->
            <input type="hidden" name="trial1_bounces" value="">
            <input type="hidden" name="trial1_count" value="">
            <input type="hidden" name="trial1_accuracy" value="">
            <!-- Trial 2 (Practice 2) -->
            <input type="hidden" name="trial2_bounces" value="">
            <input type="hidden" name="trial2_count" value="">
            <input type="hidden" name="trial2_accuracy" value="">
            <!-- Trial 3 (Critical) -->
            <input type="hidden" name="trial3_bounces" value="">
            <input type="hidden" name="trial3_count" value="">
            <input type="hidden" name="trial3_accuracy" value="">
            <input type="hidden" name="trial3_noticed" value="">
            <input type="hidden" name="trial3_shape_choice" value="">
            <!-- Trial 4 (Divided) -->
            <input type="hidden" name="trial4_bounces" value="">
            <input type="hidden" name="trial4_count" value="">
            <input type="hidden" name="trial4_accuracy" value="">
            <input type="hidden" name="trial4_noticed" value="">
            <input type="hidden" name="trial4_shape_choice" value="">
            <!-- Accuracy summary -->
            <input type="hidden" name="practice_accuracy_avg" value="">
            <!-- Playback questions -->
            <input type="hidden" name="run_smoothly" value="">
            <input type="hidden" name="glitches_description" value="">
        </form>

        <!-- Instructions Screen -->
        <div id="instructionScreen" class="screen">
            <div id="instructions">
                <p>Loading...</p>
            </div>
        </div>

        <!-- Canvas Screen (for animation) -->
        <div id="canvasScreen" class="screen hidden">
            <div id="canvasContainer">
                <canvas id="canvas" width="666" height="546"></canvas>
            </div>
        </div>

        <!-- Response Input Screen -->
        <div id="responseScreen" class="screen hidden">
            <div id="responseSection" class="response-section">
                <h2 id="responsePrompt">Enter your count:</h2>
                <div id="singleCount">
                    <label>Total bounces: </label>
                    <input type="number" id="countInput" min="0" max="100">
                    <br><br>
                    <button id="submitCount" onclick="experiment.submitResponse()">Submit</button>
                </div>
            </div>
        </div>

        <!-- Yes/No Question Screen -->
        <div id="yesNoScreen" class="screen hidden">
            <div id="yesNoSection" class="response-section">
                <h2 id="yesNoQuestion">Did you notice anything unusual?</h2>
                <button class="yesno-btn" onclick="experiment.submitYesNo('Yes')">Yes</button>
                <button class="yesno-btn" onclick="experiment.submitYesNo('No')">No</button>
            </div>
        </div>

        <!-- Shape Selection Screen -->
        <div id="shapeScreen" class="screen hidden">
            <div id="shapeSection" class="response-section">
                <h2>There actually was an extra object. If you saw it, please select the shape you saw. If you didn't see it, please guess.</h2>
                <div style="display: flex; justify-content: center; gap: 20px; margin: 20px 0;">
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('cross')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="0" y1="50" x2="100" y2="50" style="stroke:#777777; stroke-width:10"/>
                            <line x1="50" y1="0" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('Z')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="10" y1="10" x2="90" y2="10" style="stroke:#777777; stroke-width:10"/>
                            <line x1="87" y1="9" x2="13.3" y2="90" style="stroke:#777777; stroke-width:10"/>
                            <line x1="10" y1="90" x2="90" y2="90" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('L')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="25" y1="10" x2="25" y2="90" style="stroke:#777777; stroke-width:10"/>
                            <line x1="20" y1="90" x2="75" y2="90" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('T')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="10" y1="20" x2="90" y2="20" style="stroke:#777777; stroke-width:10"/>
                            <line x1="50" y1="20" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                </div>
                <button onclick="experiment.submitShapeChoice()">Submit Choice</button>
            </div>
        </div>

        <!-- Playback Questions Screen -->
        <div id="playbackScreen" class="screen hidden">
            <div id="playbackSection" class="response-section">
                <h2 id="playbackQuestion">Did the animation play smoothly?</h2>
                <button class="playback-btn" onclick="experiment.submitPlayback('Yes')">Yes</button>
                <button class="playback-btn" onclick="experiment.submitPlayback('No')">No</button>
            </div>
        </div>

        <!-- Glitches Description Screen -->
        <div id="glitchesScreen" class="screen hidden">
            <div id="glitchesSection" class="response-section">
                <h2>Please describe the playback issues you experienced:</h2>
                <input type="text" id="glitchesInput" placeholder="Describe any issues...">
                <br><br>
                <button onclick="experiment.submitGlitches()">Submit</button>
            </div>
        </div>

        <!-- Final Screen -->
        <div id="finalScreen" class="screen hidden">
            <div id="finalSection" class="response-section">
                <h2>Thank you for completing the task!</h2>
                <p>Click 'Continue' to go back to Prolific.</p>
                <button id="finalSubmit" onclick="experiment.submitData()">Continue</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // EXPERIMENT CONTROLLER
        // Pilot 8 Attend+Ignore: 4 white attended circles + 4 jittering black distractor circles
        // Instructions explicitly tell participants to ignore the black circles.
        // ============================================================
        const experiment = {
            // Configuration
            config: {
                numObjects: 4,
                numDistractors: 4,           // Number of black distractor circles
                distractorColor: 'black',    // Color of distractor circles
                distractorMidlineBuffer: 50, // Min pixels from canvas vertical center for distractors
                distractorJitterRadius: 3,   // Max pixels to jitter from anchor per frame
                distractorJitterSpeed: 0.02, // How fast jitter direction changes (lower = smoother)
                distractorMaxDrift: 8,       // Max pixels a distractor can drift from its anchor
                trialDuration: 19000,        // 19 seconds like original
                unexpectedObjectStart: 5000, // 5 seconds like original
                canvasWidth: 666,
                canvasHeight: 546,
                objectSize: 44,
                backgroundColor: '#7676A7',

                // Motion variation settings
                bounceAngleVariation: 45,    // Max degrees to deviate from perfect reflection (Ã‚Â±45Ã‚Â° = 45-135Ã‚Â° range)
                minAngleFromWall: 25,        // Minimum degrees from wall to prevent shallow/parallel movement
                perturbationIntervalMin: 500,  // Min milliseconds between random direction changes
                perturbationIntervalMax: 1000, // Max milliseconds between random direction changes
                perturbationAmount: 30,      // Max degrees for random perturbation (Ã‚Â±30Ã‚Â°)
                speedMin: 1.73,              // Minimum speed (pixels per frame at 60fps)
                speedMax: 3.17,              // Maximum speed (pixels per frame at 60fps)
                unexpectedObjectSpeed: 1.44  // UO speed (pixels per frame at 60fps)
            },

            // State tracking
            state: {
                currentTrial: 0,
                trialSequence: ['practice', 'practice', 'critical', 'divided'],
                currentPhase: 'instructions',
                isRunning: false,
                attendedColor: 'white'  // Always white in Pilot 8
            },

            // Static distractor circles (generated once, reused across trials)
            distractors: [],

            // Timing
            timing: {
                startTime: null,
                endTime: null
            },

            // Data collection
            data: {
                studyName: 'pilot8',
                subjectCode: null,
                startTime: '',
                endTime: '',
                duration: 0,
                unexpectedObjectColor: null,
                unexpectedObjectShape: null,
                unexpectedObjectDirection: null,
                trials: {
                    bounces: [],
                    counts: [],
                    accuracy: []
                },
                responses: {
                    noticed: [null, null],
                    shapeChoice: [null, null]
                },
                practiceAccuracyAvg: null,
                runSmoothly: null,
                glitchesDescription: ''
            },

            // Initialize
            init() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.objects = [];
                this.unexpectedObject = null;
                this.lastFrameTime = null; // For delta time calculation

                // Get subject_code from URL
                const urlParams = new URLSearchParams(window.location.search);
                this.data.subjectCode = urlParams.get('subject_code') || 'test_subject';
                console.log("Subject code:", this.data.subjectCode);

                // Attended color is always white in Pilot 8
                console.log("Attended color:", this.state.attendedColor);

                // Generate static distractor positions once (reused across all trials)
                this.generateDistractorPositions();

                // Record start time
                this.timing.startTime = new Date();
                this.data.startTime = this.formatDate(this.timing.startTime);

                console.log("Experiment initialized - Pilot 8 Attend+Ignore: 4 white attended + 4 jittering black distractors (explicit ignore instructions)");
                console.log("Distractor anchor positions:", this.distractors.map(d => `(${d.anchorX.toFixed(0)}, ${d.anchorY.toFixed(0)})`).join(', '));
                console.log("Using delta-time animation for consistent speed across all devices");
            },

            // Generate random positions for static distractor circles
            // Positions avoid the horizontal midline (where UO crosses) and canvas edges
            generateDistractorPositions() {
                this.distractors = [];
                const margin = this.config.objectSize; // Keep away from edges
                const midY = this.config.canvasHeight / 2;
                const buffer = this.config.distractorMidlineBuffer; // Min distance from midline

                // Place exactly 2 in upper half, 2 in lower half
                const zones = ['upper', 'upper', 'lower', 'lower'];

                for (let i = 0; i < this.config.numDistractors; i++) {
                    let x, y;
                    let attempts = 0;
                    const maxAttempts = 100;

                    do {
                        x = Math.random() * (this.config.canvasWidth - margin * 2) + margin;

                        if (zones[i] === 'upper') {
                            // Upper zone: from margin to (midY - buffer)
                            y = Math.random() * (midY - buffer - margin) + margin;
                        } else {
                            // Lower zone: from (midY + buffer) to (canvasHeight - margin)
                            y = Math.random() * (this.config.canvasHeight - margin - midY - buffer) + midY + buffer;
                        }

                        attempts++;
                    } while (
                        // Check overlap with existing distractors (min distance = objectSize * 1.5)
                        this.distractors.some(d => {
                            const dx = d.x - x;
                            const dy = d.y - y;
                            return Math.sqrt(dx * dx + dy * dy) < this.config.objectSize * 1.5;
                        }) && attempts < maxAttempts
                    );

                    this.distractors.push({
                        anchorX: x,            // Fixed anchor position
                        anchorY: y,
                        x: x,                  // Current drawn position (will jitter)
                        y: y,
                        jitterAngle: Math.random() * Math.PI * 2, // Random starting jitter direction
                        color: this.config.distractorColor,
                        size: this.config.objectSize
                    });
                }
            },

            // Format date for database (CST timezone)
            formatDate(date) {
                const options = {
                    timeZone: 'America/Chicago',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                };
                const cstDateString = new Intl.DateTimeFormat('en-US', options).format(date);
                const [datePart, timePart] = cstDateString.split(', ');
                const [month, day, year] = datePart.split('/');
                return `${year}/${month}/${day} ${timePart}`;
            },

            // Start the experiment (called from first instruction button)
            start() {
                this.startTrial();
            },

            // Show only one screen
            showScreen(screenId) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.add('hidden');
                });
                document.getElementById(screenId).classList.remove('hidden');
            },

            // Show instructions based on trial type
            showInstructions() {
                this.showScreen('instructionScreen');
                const instructions = document.getElementById('instructions');
                const trialType = this.state.trialSequence[this.state.currentTrial];

                let message = "";
                if (this.state.currentTrial === 0) {
                    // Initial instructions
                    message = `<p>In this task, white and black circles will appear inside a colored rectangle.
                              After a moment, the white circles will begin moving and bouncing off the sides of the rectangle.</p>
                              <p>Please pay attention to <strong>only the white circles</strong> and
                              <strong>ignore the black circles</strong>.</p>
                              <p>Count the total number of times the <strong>white circles</strong> bounce off
                              the sides of the rectangle.</p>
                              <p>You will be asked to report your total count.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'practice') {
                    message = `<p>On the next screen, you will do the same task. Again, count the total
                              number of times the white circles bounce off the sides of the rectangle
                              and ignore the black circles.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'critical') {
                    message = `<p>On the next screen, you will do the same task. Again, count the total
                              number of times the white circles bounce off the sides of the rectangle
                              and ignore the black circles.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'divided') {
                    message = `<p>On the next screen, you will do the same task. Again, count the total
                              number of times the white circles bounce off the sides of the rectangle
                              and ignore the black circles.</p>
                              <p><strong>NEW REQUIREMENT:</strong> This time, you should <strong>also look</strong>
                              for the presence of an extra object.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                }

                instructions.innerHTML = message;
            },

            // Start a trial
            startTrial() {
                const trialType = this.state.trialSequence[this.state.currentTrial];
                console.log("Starting trial:", this.state.currentTrial + 1, "Type:", trialType);

                this.showScreen('canvasScreen');
                this.createObjects();
                this.state.isRunning = true;
                this.lastFrameTime = null; // Reset for delta time calculation

                // Reset distractor positions to anchors for each trial
                this.distractors.forEach(d => {
                    d.x = d.anchorX;
                    d.y = d.anchorY;
                    d.jitterAngle = Math.random() * Math.PI * 2;
                });

                // Set up unexpected object for critical/divided trials
                if (trialType === 'critical' || trialType === 'divided') {
                    setTimeout(() => {
                        this.addUnexpectedObject();
                    }, this.config.unexpectedObjectStart);
                }

                // Start animation with requestAnimationFrame timestamp
                requestAnimationFrame((time) => this.animate(time));

                // End trial after duration
                setTimeout(() => {
                    this.endTrial();
                }, this.config.trialDuration);
            },

            // Helper: Rotate velocity vector by angle (in degrees)
            rotateVelocity(vx, vy, angleDegrees) {
                const angleRadians = angleDegrees * (Math.PI / 180);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                return {
                    vx: vx * cos - vy * sin,
                    vy: vx * sin + vy * cos
                };
            },

            // Helper: Get random angle within range (Ã‚Â±maxDegrees)
            getRandomAngle(maxDegrees) {
                return (Math.random() * 2 - 1) * maxDegrees; // Returns -maxDegrees to +maxDegrees
            },

            // Helper: Ensure velocity has minimum angle from wall to prevent shallow/parallel movement
            ensureMinAngleFromWall(vx, vy, wallType) {
                const speed = Math.sqrt(vx * vx + vy * vy);
                const minAngleRad = this.config.minAngleFromWall * (Math.PI / 180);
                const minComponent = speed * Math.sin(minAngleRad);

                if (wallType === 'horizontal') {
                    // For horizontal walls (top/bottom), ensure |vy| is sufficient
                    if (Math.abs(vy) < minComponent) {
                        const signY = vy >= 0 ? 1 : -1;
                        const signX = vx >= 0 ? 1 : -1;
                        vy = signY * minComponent;
                        vx = signX * Math.sqrt(speed * speed - vy * vy);
                    }
                } else if (wallType === 'vertical') {
                    // For vertical walls (left/right), ensure |vx| is sufficient
                    if (Math.abs(vx) < minComponent) {
                        const signX = vx >= 0 ? 1 : -1;
                        const signY = vy >= 0 ? 1 : -1;
                        vx = signX * minComponent;
                        vy = signY * Math.sqrt(speed * speed - vx * vx);
                    }
                }

                return { vx, vy };
            },

            // Helper: Get random perturbation interval between min and max
            getRandomPerturbationInterval() {
                return this.config.perturbationIntervalMin +
                       Math.random() * (this.config.perturbationIntervalMax - this.config.perturbationIntervalMin);
            },

            // Helper: Get random speed between min and max
            getRandomSpeed() {
                return this.config.speedMin +
                       Math.random() * (this.config.speedMax - this.config.speedMin);
            },

            // Create moving objects - all white attended circles
            createObjects() {
                this.objects = [];

                for (let i = 0; i < this.config.numObjects; i++) {
                    const margin = this.config.objectSize;
                    const speed = this.getRandomSpeed();
                    const xDir = Math.random() < 0.5 ? 1 : -1;
                    const yDir = Math.random() < 0.5 ? 1 : -1;

                    // Random initial interval and staggered start time
                    const initialInterval = this.getRandomPerturbationInterval();

                    this.objects.push({
                        x: Math.random() * (this.config.canvasWidth - margin * 2) + margin,
                        y: Math.random() * (this.config.canvasHeight - margin * 2) + margin,
                        vx: speed * xDir,
                        vy: speed * yDir,
                        color: this.state.attendedColor,  // Always white in Pilot 8
                        size: this.config.objectSize,
                        bounces: 0,
                        timeSincePerturbation: Math.random() * initialInterval, // Stagger initial perturbations
                        nextPerturbationAt: initialInterval // Random interval for this object
                    });
                }
            },

            // Add unexpected object - gray cross
            addUnexpectedObject() {
                const trialType = this.state.trialSequence[this.state.currentTrial];

                // For critical trial, randomly choose direction
                if (trialType === 'critical') {
                    this.data.unexpectedObjectColor = 'black';
                    this.data.unexpectedObjectShape = 'cross';
                    this.data.unexpectedObjectDirection = Math.random() < 0.5 ? 'LeftToRight' : 'RightToLeft';
                }
                // For divided trial, use same direction as critical

                const direction = this.data.unexpectedObjectDirection === 'LeftToRight' ? 1 : -1;
                const startX = direction === 1 ? -30 : this.config.canvasWidth + 30;
                const speed = this.config.unexpectedObjectSpeed;

                this.unexpectedObject = {
                    x: startX,
                    y: this.config.canvasHeight / 2,
                    vx: speed * direction,
                    vy: 0,
                    color: this.data.unexpectedObjectColor,
                    size: this.config.objectSize,
                    isUnexpected: true
                };

                console.log("Unexpected object: black cross",
                           "Direction:", this.data.unexpectedObjectDirection);
            },

            // Animation loop with delta time for consistent speed across all devices
            animate(currentTime) {
                if (!this.state.isRunning) return;

                // Calculate delta time (time since last frame in ms)
                if (!this.lastFrameTime) {
                    this.lastFrameTime = currentTime;
                }
                const deltaTime = currentTime - this.lastFrameTime;
                this.lastFrameTime = currentTime;

                // Target 60fps - calculate time multiplier
                // If running at 144fps, deltaTime ~7ms, multiplier ~0.42
                // If running at 60fps, deltaTime ~16.67ms, multiplier ~1.0
                // If running at 30fps, deltaTime ~33ms, multiplier ~2.0
                const targetFrameTime = 1000 / 60; // 16.67ms for 60fps
                const timeMultiplier = deltaTime / targetFrameTime;

                // Clear canvas
                this.ctx.fillStyle = this.config.backgroundColor;
                this.ctx.fillRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);

                // Draw static distractor circles FIRST (background layer)
                this.distractors.forEach(d => {
                    this.updateDistractorJitter(d, timeMultiplier);
                    this.drawObject(d);
                });

                // Draw unexpected object SECOND (middle layer, behind attended circles)
                if (this.unexpectedObject) {
                    this.updateUnexpectedObject(timeMultiplier);
                }
                if (this.unexpectedObject) {
                    this.drawCross(this.unexpectedObject);
                }

                // Update and draw attended circles LAST (top layer)
                this.objects.forEach(obj => {
                    this.updateObject(obj, timeMultiplier, deltaTime);
                    this.drawObject(obj);
                });

                // Continue animation
                requestAnimationFrame((time) => this.animate(time));
            },

            // Update object position with time-based movement
            updateObject(obj, timeMultiplier, deltaTime) {
                // Apply time multiplier for consistent speed across all frame rates
                obj.x += obj.vx * timeMultiplier;
                obj.y += obj.vy * timeMultiplier;

                const radius = obj.size / 2;
                let bouncedX = false;
                let bouncedY = false;

                // Wall collisions with variable bounce angles
                if (obj.x - radius <= 0 || obj.x + radius >= this.config.canvasWidth) {
                    // Reverse x direction
                    obj.vx *= -1;

                    // Keep in bounds
                    if (obj.x - radius <= 0) obj.x = radius;
                    if (obj.x + radius >= this.config.canvasWidth) obj.x = this.config.canvasWidth - radius;

                    // Add random angle variation to bounce
                    const angleVariation = this.getRandomAngle(this.config.bounceAngleVariation);
                    const rotated = this.rotateVelocity(obj.vx, obj.vy, angleVariation);
                    obj.vx = rotated.vx;
                    obj.vy = rotated.vy;

                    // Ensure minimum angle from wall (vertical wall = left/right)
                    const adjusted = this.ensureMinAngleFromWall(obj.vx, obj.vy, 'vertical');
                    obj.vx = adjusted.vx;
                    obj.vy = adjusted.vy;

                    bouncedX = true;
                    if (!obj.isUnexpected) obj.bounces++;
                }

                if (obj.y - radius <= 0 || obj.y + radius >= this.config.canvasHeight) {
                    // Reverse y direction
                    obj.vy *= -1;

                    // Keep in bounds
                    if (obj.y - radius <= 0) obj.y = radius;
                    if (obj.y + radius >= this.config.canvasHeight) obj.y = this.config.canvasHeight - radius;

                    // Add random angle variation to bounce (only if we didn't already rotate from x-bounce)
                    if (!bouncedX) {
                        const angleVariation = this.getRandomAngle(this.config.bounceAngleVariation);
                        const rotated = this.rotateVelocity(obj.vx, obj.vy, angleVariation);
                        obj.vx = rotated.vx;
                        obj.vy = rotated.vy;
                    }

                    // Ensure minimum angle from wall (horizontal wall = top/bottom)
                    const adjusted = this.ensureMinAngleFromWall(obj.vx, obj.vy, 'horizontal');
                    obj.vx = adjusted.vx;
                    obj.vy = adjusted.vy;

                    bouncedY = true;
                    if (!obj.isUnexpected) obj.bounces++;
                }

                // Random perturbation based on elapsed time (not frames)
                if (!bouncedX && !bouncedY) {
                    obj.timeSincePerturbation += deltaTime;
                    if (obj.timeSincePerturbation >= obj.nextPerturbationAt) {
                        // Change direction
                        const perturbation = this.getRandomAngle(this.config.perturbationAmount);
                        const rotated = this.rotateVelocity(obj.vx, obj.vy, perturbation);

                        // Change speed - normalize to unit vector then multiply by new speed
                        const currentSpeed = Math.sqrt(rotated.vx * rotated.vx + rotated.vy * rotated.vy);
                        const newSpeed = this.getRandomSpeed();
                        const speedRatio = newSpeed / currentSpeed;

                        obj.vx = rotated.vx * speedRatio;
                        obj.vy = rotated.vy * speedRatio;

                        obj.timeSincePerturbation = 0;
                        obj.nextPerturbationAt = this.getRandomPerturbationInterval(); // New random interval
                    }
                }
            },

            // Update distractor jitter - gentle random wobble around anchor position
            updateDistractorJitter(d, timeMultiplier) {
                // Slowly drift the jitter angle for smooth, organic movement
                d.jitterAngle += (Math.random() - 0.5) * this.config.distractorJitterSpeed * timeMultiplier * 60;

                // Apply small step in jitter direction
                const step = this.config.distractorJitterRadius * timeMultiplier;
                d.x += Math.cos(d.jitterAngle) * step;
                d.y += Math.sin(d.jitterAngle) * step;

                // Clamp to max drift from anchor (rubber-band back)
                const dx = d.x - d.anchorX;
                const dy = d.y - d.anchorY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > this.config.distractorMaxDrift) {
                    // Pull back toward anchor
                    const scale = this.config.distractorMaxDrift / dist;
                    d.x = d.anchorX + dx * scale;
                    d.y = d.anchorY + dy * scale;
                    // Bias jitter angle back toward anchor
                    d.jitterAngle = Math.atan2(d.anchorY - d.y, d.anchorX - d.x) + (Math.random() - 0.5) * Math.PI * 0.5;
                }
            },

            // Update unexpected object with time-based movement
            updateUnexpectedObject(timeMultiplier) {
                if (this.unexpectedObject) {
                    this.unexpectedObject.x += this.unexpectedObject.vx * timeMultiplier;

                    // Remove when off screen
                    if (this.unexpectedObject.vx > 0 && this.unexpectedObject.x > this.config.canvasWidth + 30) {
                        this.unexpectedObject = null;
                    } else if (this.unexpectedObject.vx < 0 && this.unexpectedObject.x < -30) {
                        this.unexpectedObject = null;
                    }
                }
            },

            // Draw circle object
            drawObject(obj) {
                this.ctx.fillStyle = obj.color;
                this.ctx.beginPath();
                this.ctx.arc(obj.x, obj.y, obj.size / 2, 0, Math.PI * 2);
                this.ctx.fill();
            },

            // Draw cross (for unexpected object)
            drawCross(obj) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.strokeStyle = obj.color;
                this.ctx.lineWidth = obj.size / 4;
                // Draw horizontal line
                this.ctx.moveTo(obj.x - obj.size / 2, obj.y);
                this.ctx.lineTo(obj.x + obj.size / 2, obj.y);
                // Draw vertical line
                this.ctx.moveTo(obj.x, obj.y - obj.size / 2);
                this.ctx.lineTo(obj.x, obj.y + obj.size / 2);
                this.ctx.stroke();
                this.ctx.restore();
            },

            // End trial
            endTrial() {
                this.state.isRunning = false;
                this.unexpectedObject = null;

                // Calculate bounces
                let totalBounces = 0;
                this.objects.forEach(obj => {
                    totalBounces += obj.bounces;
                });

                this.data.trials.bounces.push(totalBounces);
                console.log("Trial", this.state.currentTrial + 1, "- Actual bounces:", totalBounces);

                this.showResponseInput();
            },

            // Show response input
            showResponseInput() {
                this.showScreen('responseScreen');
                document.getElementById('responsePrompt').textContent =
                    `In the box below, please enter the total number of times the white circles bounced off the edges of the rectangle.`;
                document.getElementById('countInput').value = '';
                document.getElementById('countInput').focus();
            },

            // Submit counting response
            submitResponse() {
                const count = parseInt(document.getElementById('countInput').value) || 0;
                this.data.trials.counts.push(count);

                // Calculate accuracy
                const trialIndex = this.data.trials.counts.length - 1;
                const actual = this.data.trials.bounces[trialIndex];
                const percentError = Math.abs(count - actual) / actual * 100;
                const accuracy = Math.max(0, Math.min(100, 100 - percentError));
                this.data.trials.accuracy.push(parseFloat(accuracy.toFixed(2)));

                console.log("Count submitted:", count, "Actual:", actual, "Accuracy:", accuracy.toFixed(2) + "%");

                const trialType = this.state.trialSequence[this.state.currentTrial];

                if (trialType === 'critical') {
                    this.showNoticeQuestion();
                } else if (trialType === 'divided') {
                    this.showNoticeQuestion();
                } else {
                    this.nextTrial();
                }
            },

            // Show notice question
            showNoticeQuestion() {
                this.showScreen('yesNoScreen');
                const trialType = this.state.trialSequence[this.state.currentTrial];

                if (trialType === 'critical') {
                    document.getElementById('yesNoQuestion').textContent =
                        "Did you notice anything extra during the last counting trial that wasn't there in the previous trials?";
                } else {
                    document.getElementById('yesNoQuestion').textContent =
                        "Did you notice an extra object on that trial?";
                }
            },

            // Submit yes/no response
            submitYesNo(answer) {
                const trialType = this.state.trialSequence[this.state.currentTrial];
                const responseIndex = trialType === 'critical' ? 0 : 1;
                this.data.responses.noticed[responseIndex] = answer;

                console.log("Noticed:", answer, "Trial type:", trialType);

                this.showShapeSelection();
            },

            // Show shape selection
            showShapeSelection() {
                this.showScreen('shapeScreen');
                // Clear previous selection
                document.querySelectorAll('#shapeSection .shape-choice').forEach(el => {
                    el.classList.remove('selected');
                });
                this.selectedShape = null;
            },

            // Select a shape
            selectShape(shape) {
                document.querySelectorAll('#shapeSection .shape-choice').forEach(el => {
                    el.classList.remove('selected');
                });
                event.currentTarget.classList.add('selected');
                this.selectedShape = shape;
            },

            // Submit shape choice
            submitShapeChoice() {
                if (!this.selectedShape) {
                    alert("Please select a shape");
                    return;
                }

                const trialType = this.state.trialSequence[this.state.currentTrial];
                const responseIndex = trialType === 'critical' ? 0 : 1;
                this.data.responses.shapeChoice[responseIndex] = this.selectedShape;

                console.log("Shape choice:", this.selectedShape);

                this.nextTrial();
            },

            // Move to next trial
            nextTrial() {
                this.state.currentTrial++;

                if (this.state.currentTrial < this.state.trialSequence.length) {
                    this.showInstructions();
                } else {
                    this.showPlaybackQuestion();
                }
            },

            // Show playback question
            showPlaybackQuestion() {
                // Calculate practice accuracy average first
                const practiceAcc1 = this.data.trials.accuracy[0] || 0;
                const practiceAcc2 = this.data.trials.accuracy[1] || 0;
                this.data.practiceAccuracyAvg = parseFloat(((practiceAcc1 + practiceAcc2) / 2).toFixed(2));

                this.showScreen('playbackScreen');
                document.getElementById('playbackQuestion').textContent =
                    "Did the animation play smoothly, with no obvious lagging or freezing?";
            },

            // Submit playback response
            submitPlayback(answer) {
                this.data.runSmoothly = answer;
                console.log("Run smoothly:", answer);

                if (answer === 'No') {
                    this.showGlitchesScreen();
                } else {
                    this.showFinalScreen();
                }
            },

            // Show glitches description screen
            showGlitchesScreen() {
                this.showScreen('glitchesScreen');
                document.getElementById('glitchesInput').value = '';
            },

            // Submit glitches description
            submitGlitches() {
                this.data.glitchesDescription = document.getElementById('glitchesInput').value;
                console.log("Glitches description:", this.data.glitchesDescription);
                this.showFinalScreen();
            },

            // Show final screen
            showFinalScreen() {
                this.showScreen('finalScreen');
            },

            // Submit all data
            submitData() {
                // Record end time
                this.timing.endTime = new Date();
                this.data.endTime = this.formatDate(this.timing.endTime);
                this.data.duration = Math.round((this.timing.endTime - this.timing.startTime) / 1000);

                // Fill in form fields
                const form = document.getElementById('task_data');
                form.study_name.value = this.data.studyName;
                form.subject_code.value = this.data.subjectCode;
                form.start_time.value = this.data.startTime;
                form.end_time.value = this.data.endTime;
                form.duration.value = this.data.duration;
                form.background_color.value = this.config.backgroundColor;
                form.attended_color.value = this.state.attendedColor;
                form.bounce_angle_variation.value = this.config.bounceAngleVariation;
                form.min_angle_from_wall.value = this.config.minAngleFromWall;
                form.perturbation_interval_min.value = this.config.perturbationIntervalMin;
                form.perturbation_interval_max.value = this.config.perturbationIntervalMax;
                form.perturbation_amount.value = this.config.perturbationAmount;
                form.speed_min.value = this.config.speedMin;
                form.speed_max.value = this.config.speedMax;
                form.unexpected_object_speed.value = this.config.unexpectedObjectSpeed;
                form.unexpected_object_color.value = this.data.unexpectedObjectColor || '';
                form.unexpected_object_shape.value = this.data.unexpectedObjectShape || '';
                form.unexpected_object_direction.value = this.data.unexpectedObjectDirection || '';

                // Distractor info
                form.num_distractors.value = this.config.numDistractors;
                form.distractor_color.value = this.config.distractorColor;
                form.distractor_positions.value = JSON.stringify(
                    this.distractors.map(d => ({ x: Math.round(d.anchorX), y: Math.round(d.anchorY) }))
                );
                form.distractor_motion.value = 'jitter';

                // Trial 1 (Practice 1)
                form.trial1_bounces.value = this.data.trials.bounces[0] || '';
                form.trial1_count.value = this.data.trials.counts[0] || '';
                form.trial1_accuracy.value = this.data.trials.accuracy[0] || '';

                // Trial 2 (Practice 2)
                form.trial2_bounces.value = this.data.trials.bounces[1] || '';
                form.trial2_count.value = this.data.trials.counts[1] || '';
                form.trial2_accuracy.value = this.data.trials.accuracy[1] || '';

                // Trial 3 (Critical)
                form.trial3_bounces.value = this.data.trials.bounces[2] || '';
                form.trial3_count.value = this.data.trials.counts[2] || '';
                form.trial3_accuracy.value = this.data.trials.accuracy[2] || '';
                form.trial3_noticed.value = this.data.responses.noticed[0] || '';
                form.trial3_shape_choice.value = this.data.responses.shapeChoice[0] || '';

                // Trial 4 (Divided)
                form.trial4_bounces.value = this.data.trials.bounces[3] || '';
                form.trial4_count.value = this.data.trials.counts[3] || '';
                form.trial4_accuracy.value = this.data.trials.accuracy[3] || '';
                form.trial4_noticed.value = this.data.responses.noticed[1] || '';
                form.trial4_shape_choice.value = this.data.responses.shapeChoice[1] || '';

                // Accuracy summary
                form.practice_accuracy_avg.value = this.data.practiceAccuracyAvg || '';

                // Playback
                form.run_smoothly.value = this.data.runSmoothly || '';
                form.glitches_description.value = this.data.glitchesDescription || '';

                // Log all data for debugging
                console.log("=== FINAL DATA ===");
                console.log("Study name:", this.data.studyName);
                console.log("Subject:", this.data.subjectCode);
                console.log("Duration:", this.data.duration, "seconds");
                console.log("Attended color:", this.state.attendedColor);
                console.log("Motion settings - Bounce angle variation:", this.config.bounceAngleVariation + "Ã‚Â°");
                console.log("Motion settings - Min angle from wall:", this.config.minAngleFromWall + "Ã‚Â°");
                console.log("Motion settings - Perturbation interval:", this.config.perturbationIntervalMin + "-" + this.config.perturbationIntervalMax, "ms");
                console.log("Motion settings - Perturbation amount:", this.config.perturbationAmount + "Ã‚Â°");
                console.log("Motion settings - Speed range:", this.config.speedMin + "-" + this.config.speedMax, "px/frame");
                console.log("Motion settings - UO speed:", this.config.unexpectedObjectSpeed, "px/frame");
                console.log("Distractors:", this.config.numDistractors, this.config.distractorColor, "jittering circles at:",
                    this.distractors.map(d => `(${Math.round(d.anchorX)}, ${Math.round(d.anchorY)})`).join(', '));
                console.log("Bounces:", this.data.trials.bounces);
                console.log("Counts:", this.data.trials.counts);
                console.log("Accuracy:", this.data.trials.accuracy);
                console.log("Practice Avg:", this.data.practiceAccuracyAvg);
                console.log("UO Color:", this.data.unexpectedObjectColor);
                console.log("UO Shape:", this.data.unexpectedObjectShape);
                console.log("UO Direction:", this.data.unexpectedObjectDirection);
                console.log("Noticed:", this.data.responses.noticed);
                console.log("Shape Choice:", this.data.responses.shapeChoice);
                console.log("==================");

                // Create data object for submission
                const formData = new FormData(form);
                const dataObject = {};
                formData.forEach((value, key) => {
                    dataObject[key] = value;
                });

                const json = JSON.stringify(dataObject);
                console.log("JSON being sent:", json);

                // Send data via XMLHttpRequest
                const xhr = new XMLHttpRequest();
                xhr.open("POST", "data.php", true);
                xhr.setRequestHeader("Content-Type", "application/json");
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        console.log("Server response:", xhr.responseText);
                        if (xhr.status === 200) {
                            // Redirect to Prolific
                            window.location.href = 'https://app.prolific.com/submissions/complete?cc=C1QBLCRQ';
                            console.log("Data submitted successfully.");
                        } else {
                            console.error("Error submitting data");
                        }
                    }
                };
                xhr.send(json);
            }
        };

        // ============================================================
        // INITIALIZATION
        // ============================================================
        window.onload = function() {
            console.log("Page loaded - Experiment ready!");
            // Initialize and show first instructions
            experiment.init();
            experiment.showInstructions();
        };
    </script>
</body>
</html>