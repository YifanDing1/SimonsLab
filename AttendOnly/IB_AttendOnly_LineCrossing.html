<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inattentional Blindness Experiment - Line Crossing</title>
    <style>
        /* STYLING */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        #experimentContainer {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #canvasContainer {
            text-align: center;
            min-height: 600px;
        }

        #canvas {
            display: block;
            margin: 20px auto;
            border: 2px solid #333;
            background-color: #7676A7;
        }

        button {
            font-size: 18px;
            padding: 10px 20px;
            margin: 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        input[type="number"] {
            font-size: 16px;
            padding: 5px;
            width: 80px;
            margin: 5px;
        }

        input[type="text"] {
            font-size: 16px;
            padding: 5px;
            width: 300px;
            margin: 5px;
        }

        .hidden {
            display: none !important;
        }

        #instructions {
            text-align: center;
            margin: 20px;
            font-size: 18px;
            line-height: 1.5;
            min-height: 200px;
            padding: 40px;
        }

        .response-section {
            background: #f9f9f9;
            padding: 40px;
            border-radius: 5px;
            margin: 10px auto;
            min-height: 300px;
            max-width: 600px;
            text-align: center;
        }

        .choice-button {
            display: inline-block;
            margin: 10px;
            padding: 15px 30px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            background-color: white;
        }

        .choice-button:hover {
            border-color: #4CAF50;
            background-color: #f0f0f0;
        }

        .choice-button.selected {
            border-color: #4CAF50;
            background-color: #e8f5e9;
        }

        .screen {
            min-height: 500px;
        }
    </style>
</head>
<body>
    <div id="experimentContainer">
        <!-- Hidden form for data submission -->
        <form id="task_data" name="task_data" action="data.php" method="post">
            <input type="hidden" name="study_name" value="">
            <input type="hidden" name="subject_code" value="">
            <input type="hidden" name="start_time" value="">
            <input type="hidden" name="end_time" value="">
            <input type="hidden" name="duration" value="">
            <input type="hidden" name="background_color" value="">
            <input type="hidden" name="attended_color" value="">
            <input type="hidden" name="line_color" value="">
            <input type="hidden" name="top_line_position" value="">
            <input type="hidden" name="bottom_line_position" value="">
            <input type="hidden" name="bounce_angle_variation" value="">
            <input type="hidden" name="min_angle_from_wall" value="">
            <input type="hidden" name="perturbation_interval_min" value="">
            <input type="hidden" name="perturbation_interval_max" value="">
            <input type="hidden" name="perturbation_amount" value="">
            <input type="hidden" name="speed_min" value="">
            <input type="hidden" name="speed_max" value="">
            <input type="hidden" name="unexpected_object_speed" value="">
            <input type="hidden" name="unexpected_object_color" value="">
            <input type="hidden" name="unexpected_object_shape" value="">
            <input type="hidden" name="unexpected_object_direction" value="">
            <!-- Trial 1 (Practice 1) -->
            <input type="hidden" name="trial1_crossings" value="">
            <input type="hidden" name="trial1_count" value="">
            <input type="hidden" name="trial1_accuracy" value="">
            <!-- Trial 2 (Practice 2) -->
            <input type="hidden" name="trial2_crossings" value="">
            <input type="hidden" name="trial2_count" value="">
            <input type="hidden" name="trial2_accuracy" value="">
            <!-- Trial 3 (Critical) -->
            <input type="hidden" name="trial3_crossings" value="">
            <input type="hidden" name="trial3_count" value="">
            <input type="hidden" name="trial3_accuracy" value="">
            <input type="hidden" name="trial3_noticed" value="">
            <input type="hidden" name="trial3_shape_choice" value="">
            <!-- Trial 4 (Divided) -->
            <input type="hidden" name="trial4_crossings" value="">
            <input type="hidden" name="trial4_count" value="">
            <input type="hidden" name="trial4_accuracy" value="">
            <input type="hidden" name="trial4_noticed" value="">
            <input type="hidden" name="trial4_shape_choice" value="">
            <!-- Accuracy summary -->
            <input type="hidden" name="practice_accuracy_avg" value="">
            <!-- Playback questions -->
            <input type="hidden" name="run_smoothly" value="">
            <input type="hidden" name="glitches_description" value="">
        </form>

        <!-- Instructions Screen -->
        <div id="instructionScreen" class="screen">
            <div id="instructions">
                <p>Loading...</p>
            </div>
        </div>

        <!-- Canvas Screen (for animation) -->
        <div id="canvasScreen" class="screen hidden">
            <div id="canvasContainer">
                <canvas id="canvas" width="666" height="546"></canvas>
            </div>
        </div>

        <!-- Response Input Screen -->
        <div id="responseScreen" class="screen hidden">
            <div id="responseSection" class="response-section">
                <h2 id="responsePrompt">Enter your count:</h2>
                <div id="singleCount">
                    <label>Total touches: </label>
                    <input type="number" id="countInput" min="0" max="200">
                    <br><br>
                    <button id="submitCount" onclick="experiment.submitResponse()">Submit</button>
                </div>
            </div>
        </div>

        <!-- Yes/No Question Screen -->
        <div id="yesNoScreen" class="screen hidden">
            <div id="yesNoSection" class="response-section">
                <h2 id="yesNoQuestion">Did you notice anything unusual?</h2>
                <button class="yesno-btn" onclick="experiment.submitYesNo('Yes')">Yes</button>
                <button class="yesno-btn" onclick="experiment.submitYesNo('No')">No</button>
            </div>
        </div>

        <!-- Shape Selection Screen -->
        <div id="shapeScreen" class="screen hidden">
            <div id="shapeSection" class="response-section">
                <h2>There actually was an extra object. If you saw it, please select the shape you saw. If you didn't see it, please guess.</h2>
                <div style="display: flex; justify-content: center; gap: 20px; margin: 20px 0;">
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('cross')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="0" y1="50" x2="100" y2="50" style="stroke:#777777; stroke-width:10"/>
                            <line x1="50" y1="0" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('Z')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="10" y1="10" x2="90" y2="10" style="stroke:#777777; stroke-width:10"/>
                            <line x1="87" y1="9" x2="13.3" y2="90" style="stroke:#777777; stroke-width:10"/>
                            <line x1="10" y1="90" x2="90" y2="90" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('L')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="25" y1="10" x2="25" y2="90" style="stroke:#777777; stroke-width:10"/>
                            <line x1="20" y1="90" x2="75" y2="90" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                    <div class="choice-button shape-choice" onclick="experiment.selectShape('T')" style="padding: 10px;">
                        <svg width="70" height="70" viewBox="0 0 100 100">
                            <line x1="10" y1="20" x2="90" y2="20" style="stroke:#777777; stroke-width:10"/>
                            <line x1="50" y1="20" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                        </svg>
                    </div>
                </div>
                <button onclick="experiment.submitShapeChoice()">Submit Choice</button>
            </div>
        </div>

        <!-- Playback Questions Screen -->
        <div id="playbackScreen" class="screen hidden">
            <div id="playbackSection" class="response-section">
                <h2 id="playbackQuestion">Did the animation play smoothly?</h2>
                <button class="playback-btn" onclick="experiment.submitPlayback('Yes')">Yes</button>
                <button class="playback-btn" onclick="experiment.submitPlayback('No')">No</button>
            </div>
        </div>

        <!-- Glitches Description Screen -->
        <div id="glitchesScreen" class="screen hidden">
            <div id="glitchesSection" class="response-section">
                <h2>Please describe the playback issues you experienced:</h2>
                <input type="text" id="glitchesInput" placeholder="Describe any issues...">
                <br><br>
                <button onclick="experiment.submitGlitches()">Submit</button>
            </div>
        </div>

        <!-- Final Screen -->
        <div id="finalScreen" class="screen hidden">
            <div id="finalSection" class="response-section">
                <h2>Thank you for completing the task!</h2>
                <p>Click 'Continue' to go back to Prolific.</p>
                <button id="finalSubmit" onclick="experiment.submitData()">Continue</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // EXPERIMENT CONTROLLER
        // 4 circles that are randomly either all white or all black
        // Counts crossings of two horizontal lines (at 25% and 75% height)
        // ============================================================
        const experiment = {
            // Configuration
            config: {
                numObjects: 4,
                trialDuration: 19000,        // 19 seconds like original
                unexpectedObjectStart: 5000, // 5 seconds like original
                canvasWidth: 666,
                canvasHeight: 546,
                objectSize: 44,
                backgroundColor: '#7676A7',

                // Line configuration
                topLinePosition: 0.25,       // 25% from top
                bottomLinePosition: 0.75,    // 75% from top
                lineColor: '#999999',        // Midgray lines (between white and black)
                lineWidth: 2,                // Thin line (2 pixels)

                // Trial timing
                initialPauseTime: 500,       // 0.5 seconds pause at start with circles visible

                // Motion variation settings
                bounceAngleVariation: 45,    // Max degrees to deviate from perfect reflection
                minAngleFromWall: 25,        // Minimum degrees from wall
                perturbationIntervalMin: 500,
                perturbationIntervalMax: 1000,
                perturbationAmount: 30,
                speedMin: 1.73,
                speedMax: 3.17,
                unexpectedObjectSpeed: 1.44
            },

            // State tracking
            state: {
                currentTrial: 0,
                trialSequence: ['practice', 'practice', 'critical', 'divided'],
                currentPhase: 'instructions',
                isRunning: false,
                attendedColor: null  // Will be randomly assigned: 'white' or 'black'
            },

            // Timing
            timing: {
                startTime: null,
                endTime: null
            },

            // Data collection
            data: {
                studyName: 'pilot4',
                subjectCode: null,
                startTime: '',
                endTime: '',
                duration: 0,
                unexpectedObjectColor: null,
                unexpectedObjectShape: null,
                unexpectedObjectDirection: null,
                trials: {
                    crossings: [],   // Changed from bounces to crossings
                    counts: [],
                    accuracy: []
                },
                responses: {
                    noticed: [null, null],
                    shapeChoice: [null, null]
                },
                practiceAccuracyAvg: null,
                runSmoothly: null,
                glitchesDescription: ''
            },

            // Initialize
            init() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.objects = [];
                this.unexpectedObject = null;
                this.lastFrameTime = null;

                // Calculate actual line Y positions
                this.topLineY = this.config.canvasHeight * this.config.topLinePosition;
                this.bottomLineY = this.config.canvasHeight * this.config.bottomLinePosition;

                // Get subject_code from URL
                const urlParams = new URLSearchParams(window.location.search);
                this.data.subjectCode = urlParams.get('subject_code') || 'test_subject';
                console.log("Subject code:", this.data.subjectCode);

                // Randomly assign attended color: white or black
                this.state.attendedColor = Math.random() < 0.5 ? 'white' : 'black';
                console.log("Attended color:", this.state.attendedColor);

                // Record start time
                this.timing.startTime = new Date();
                this.data.startTime = this.formatDate(this.timing.startTime);

                console.log("Experiment initialized - 4", this.state.attendedColor, "circles");
                console.log("Line positions: top =", this.topLineY, "px, bottom =", this.bottomLineY, "px");
                console.log("Counting line touches (must fully leave line before touching again counts)");
            },

            // Format date for database (CST timezone)
            formatDate(date) {
                const options = {
                    timeZone: 'America/Chicago',
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                };
                const cstDateString = new Intl.DateTimeFormat('en-US', options).format(date);
                const [datePart, timePart] = cstDateString.split(', ');
                const [month, day, year] = datePart.split('/');
                return `${year}/${month}/${day} ${timePart}`;
            },

            // Start the experiment
            start() {
                this.startTrial();
            },

            // Show only one screen
            showScreen(screenId) {
                document.querySelectorAll('.screen').forEach(screen => {
                    screen.classList.add('hidden');
                });
                document.getElementById(screenId).classList.remove('hidden');
            },

            // Show instructions based on trial type
            showInstructions() {
                this.showScreen('instructionScreen');
                const instructions = document.getElementById('instructions');
                const trialType = this.state.trialSequence[this.state.currentTrial];

                let message = "";
                if (this.state.currentTrial === 0) {
                    // Initial instructions
                    message = `<p>In this task, 4 circles will appear inside a colored rectangle with two horizontal lines.
                              After a moment, they will begin moving and bouncing off the sides of the rectangle.</p>
                              <p>Please count the total number of times any circle touches either of the two horizontal lines.
                              Each touch counts once - a circle must fully leave the line before touching it again to count.</p>
                              <p>You will be asked to report your total count.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'practice') {
                    message = `<p>On the next screen, you will do the same task. Again, please count the total
                              number of times any circle touches either of the two horizontal lines.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'critical') {
                    message = `<p>On the next screen, you will do the same task. Again, please count the total
                              number of times any circle touches either of the two horizontal lines.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                } else if (trialType === 'divided') {
                    message = `<p>On the next screen, you will do the same task. Again, please count the total
                              number of times any circle touches either of the two horizontal lines.</p>
                              <p><strong>NEW REQUIREMENT:</strong> This time, you should <strong>also look</strong>
                              for the presence of an extra object.</p>
                              <br><button onclick="experiment.startTrial()">Click to begin</button>`;
                }

                instructions.innerHTML = message;
            },

            // Start a trial
            startTrial() {
                const trialType = this.state.trialSequence[this.state.currentTrial];
                console.log("Starting trial:", this.state.currentTrial + 1, "Type:", trialType);

                this.showScreen('canvasScreen');
                this.createObjects();
                this.lastFrameTime = null;

                // Draw initial static display (circles visible but not moving)
                this.drawStaticDisplay();

                // After initial pause, start the animation
                setTimeout(() => {
                    this.state.isRunning = true;

                    // Set up unexpected object for critical/divided trials
                    if (trialType === 'critical' || trialType === 'divided') {
                        setTimeout(() => {
                            this.addUnexpectedObject();
                        }, this.config.unexpectedObjectStart);
                    }

                    // Start animation
                    requestAnimationFrame((time) => this.animate(time));

                    // End trial after duration (from when movement starts)
                    setTimeout(() => {
                        this.endTrial();
                    }, this.config.trialDuration);

                }, this.config.initialPauseTime);
            },

            // Draw the static display (before animation starts)
            drawStaticDisplay() {
                // Clear canvas
                this.ctx.fillStyle = this.config.backgroundColor;
                this.ctx.fillRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);

                // Draw the two horizontal lines
                this.drawLines();

                // Draw all objects in their starting positions
                this.objects.forEach(obj => {
                    this.drawObject(obj);
                });
            },

            // Helper: Rotate velocity vector by angle (in degrees)
            rotateVelocity(vx, vy, angleDegrees) {
                const angleRadians = angleDegrees * (Math.PI / 180);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                return {
                    vx: vx * cos - vy * sin,
                    vy: vx * sin + vy * cos
                };
            },

            // Helper: Get random angle within range
            getRandomAngle(maxDegrees) {
                return (Math.random() * 2 - 1) * maxDegrees;
            },

            // Helper: Ensure velocity has minimum angle from wall
            ensureMinAngleFromWall(vx, vy, wallType) {
                const speed = Math.sqrt(vx * vx + vy * vy);
                const minAngleRad = this.config.minAngleFromWall * (Math.PI / 180);
                const minComponent = speed * Math.sin(minAngleRad);

                if (wallType === 'horizontal') {
                    if (Math.abs(vy) < minComponent) {
                        const signY = vy >= 0 ? 1 : -1;
                        const signX = vx >= 0 ? 1 : -1;
                        vy = signY * minComponent;
                        vx = signX * Math.sqrt(speed * speed - vy * vy);
                    }
                } else if (wallType === 'vertical') {
                    if (Math.abs(vx) < minComponent) {
                        const signX = vx >= 0 ? 1 : -1;
                        const signY = vy >= 0 ? 1 : -1;
                        vx = signX * minComponent;
                        vy = signY * Math.sqrt(speed * speed - vx * vx);
                    }
                }

                return { vx, vy };
            },

            // Helper: Get random perturbation interval
            getRandomPerturbationInterval() {
                return this.config.perturbationIntervalMin +
                       Math.random() * (this.config.perturbationIntervalMax - this.config.perturbationIntervalMin);
            },

            // Helper: Get random speed
            getRandomSpeed() {
                return this.config.speedMin +
                       Math.random() * (this.config.speedMax - this.config.speedMin);
            },

            // Create moving objects
            createObjects() {
                this.objects = [];

                for (let i = 0; i < this.config.numObjects; i++) {
                    const margin = this.config.objectSize;
                    const speed = this.getRandomSpeed();
                    const xDir = Math.random() < 0.5 ? 1 : -1;
                    const yDir = Math.random() < 0.5 ? 1 : -1;

                    const initialInterval = this.getRandomPerturbationInterval();

                    // Random starting Y position
                    const startY = Math.random() * (this.config.canvasHeight - margin * 2) + margin;

                    // Calculate initial touch states based on starting position
                    const radius = this.config.objectSize / 2;
                    const touchingTop = Math.abs(startY - this.topLineY) <= radius;
                    const touchingBottom = Math.abs(startY - this.bottomLineY) <= radius;

                    this.objects.push({
                        x: Math.random() * (this.config.canvasWidth - margin * 2) + margin,
                        y: startY,
                        vx: speed * xDir,
                        vy: speed * yDir,
                        color: this.state.attendedColor,
                        size: this.config.objectSize,
                        crossings: 0,   // Count line crossings
                        touchingTopLine: touchingTop,      // Track if currently touching top line
                        touchingBottomLine: touchingBottom, // Track if currently touching bottom line
                        timeSincePerturbation: Math.random() * initialInterval,
                        nextPerturbationAt: initialInterval
                    });
                }
            },

            // Add unexpected object - gray cross
            addUnexpectedObject() {
                const trialType = this.state.trialSequence[this.state.currentTrial];

                if (trialType === 'critical') {
                    this.data.unexpectedObjectColor = '#777777';
                    this.data.unexpectedObjectShape = 'cross';
                    this.data.unexpectedObjectDirection = Math.random() < 0.5 ? 'LeftToRight' : 'RightToLeft';
                }

                const direction = this.data.unexpectedObjectDirection === 'LeftToRight' ? 1 : -1;
                const startX = direction === 1 ? -30 : this.config.canvasWidth + 30;
                const speed = this.config.unexpectedObjectSpeed;

                this.unexpectedObject = {
                    x: startX,
                    y: this.config.canvasHeight / 2,
                    vx: speed * direction,
                    vy: 0,
                    color: this.data.unexpectedObjectColor,
                    size: this.config.objectSize,
                    isUnexpected: true
                };

                console.log("Unexpected object: gray cross",
                           "Direction:", this.data.unexpectedObjectDirection);
            },

            // Animation loop with delta time
            animate(currentTime) {
                if (!this.state.isRunning) return;

                if (!this.lastFrameTime) {
                    this.lastFrameTime = currentTime;
                }
                const deltaTime = currentTime - this.lastFrameTime;
                this.lastFrameTime = currentTime;

                const targetFrameTime = 1000 / 60;
                const timeMultiplier = deltaTime / targetFrameTime;

                // Clear canvas
                this.ctx.fillStyle = this.config.backgroundColor;
                this.ctx.fillRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);

                // Draw the two horizontal lines
                this.drawLines();

                // Draw unexpected object FIRST (behind circles)
                if (this.unexpectedObject) {
                    this.updateUnexpectedObject(timeMultiplier);
                }
                if (this.unexpectedObject) {
                    this.drawCross(this.unexpectedObject);
                }

                // Update and draw regular objects
                this.objects.forEach(obj => {
                    this.updateObject(obj, timeMultiplier, deltaTime);
                    this.drawObject(obj);
                });

                // Continue animation
                requestAnimationFrame((time) => this.animate(time));
            },

            // Draw the two horizontal lines
            drawLines() {
                this.ctx.strokeStyle = this.config.lineColor;
                this.ctx.lineWidth = this.config.lineWidth;

                // Top line (at 25%)
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.topLineY);
                this.ctx.lineTo(this.config.canvasWidth, this.topLineY);
                this.ctx.stroke();

                // Bottom line (at 75%)
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.bottomLineY);
                this.ctx.lineTo(this.config.canvasWidth, this.bottomLineY);
                this.ctx.stroke();
            },

            // Check if disk is touching a line (edge of disk reaches line)
            isDiskTouchingLine(diskY, lineY, radius) {
                return Math.abs(diskY - lineY) <= radius;
            },

            // Update object position
            updateObject(obj, timeMultiplier, deltaTime) {
                // Apply movement
                obj.x += obj.vx * timeMultiplier;
                obj.y += obj.vy * timeMultiplier;

                const radius = obj.size / 2;

                // Check if disk is currently touching each line
                const nowTouchingTop = this.isDiskTouchingLine(obj.y, this.topLineY, radius);
                const nowTouchingBottom = this.isDiskTouchingLine(obj.y, this.bottomLineY, radius);

                // Count crossing only when disk starts touching (wasn't touching before, is touching now)
                // This means it must fully leave the line before it can be counted again
                if (nowTouchingTop && !obj.touchingTopLine) {
                    obj.crossings++;
                }
                if (nowTouchingBottom && !obj.touchingBottomLine) {
                    obj.crossings++;
                }

                // Update touch states
                obj.touchingTopLine = nowTouchingTop;
                obj.touchingBottomLine = nowTouchingBottom;

                // Wall collisions (still bounce off walls, just don't count)
                if (obj.x - radius <= 0 || obj.x + radius >= this.config.canvasWidth) {
                    obj.vx *= -1;
                    if (obj.x - radius <= 0) obj.x = radius;
                    if (obj.x + radius >= this.config.canvasWidth) obj.x = this.config.canvasWidth - radius;

                    const angleVariation = this.getRandomAngle(this.config.bounceAngleVariation);
                    const rotated = this.rotateVelocity(obj.vx, obj.vy, angleVariation);
                    obj.vx = rotated.vx;
                    obj.vy = rotated.vy;

                    const adjusted = this.ensureMinAngleFromWall(obj.vx, obj.vy, 'vertical');
                    obj.vx = adjusted.vx;
                    obj.vy = adjusted.vy;
                }

                if (obj.y - radius <= 0 || obj.y + radius >= this.config.canvasHeight) {
                    obj.vy *= -1;
                    if (obj.y - radius <= 0) obj.y = radius;
                    if (obj.y + radius >= this.config.canvasHeight) obj.y = this.config.canvasHeight - radius;

                    const angleVariation = this.getRandomAngle(this.config.bounceAngleVariation);
                    const rotated = this.rotateVelocity(obj.vx, obj.vy, angleVariation);
                    obj.vx = rotated.vx;
                    obj.vy = rotated.vy;

                    const adjusted = this.ensureMinAngleFromWall(obj.vx, obj.vy, 'horizontal');
                    obj.vx = adjusted.vx;
                    obj.vy = adjusted.vy;
                }

                // Random perturbation
                obj.timeSincePerturbation += deltaTime;
                if (obj.timeSincePerturbation >= obj.nextPerturbationAt) {
                    const perturbation = this.getRandomAngle(this.config.perturbationAmount);
                    const rotated = this.rotateVelocity(obj.vx, obj.vy, perturbation);

                    const currentSpeed = Math.sqrt(rotated.vx * rotated.vx + rotated.vy * rotated.vy);
                    const newSpeed = this.getRandomSpeed();
                    const speedRatio = newSpeed / currentSpeed;

                    obj.vx = rotated.vx * speedRatio;
                    obj.vy = rotated.vy * speedRatio;

                    obj.timeSincePerturbation = 0;
                    obj.nextPerturbationAt = this.getRandomPerturbationInterval();
                }
            },

            // Update unexpected object
            updateUnexpectedObject(timeMultiplier) {
                if (this.unexpectedObject) {
                    this.unexpectedObject.x += this.unexpectedObject.vx * timeMultiplier;

                    if (this.unexpectedObject.vx > 0 && this.unexpectedObject.x > this.config.canvasWidth + 30) {
                        this.unexpectedObject = null;
                    } else if (this.unexpectedObject.vx < 0 && this.unexpectedObject.x < -30) {
                        this.unexpectedObject = null;
                    }
                }
            },

            // Draw circle object
            drawObject(obj) {
                this.ctx.fillStyle = obj.color;
                this.ctx.beginPath();
                this.ctx.arc(obj.x, obj.y, obj.size / 2, 0, Math.PI * 2);
                this.ctx.fill();
            },

            // Draw cross (for unexpected object)
            drawCross(obj) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.strokeStyle = obj.color;
                this.ctx.lineWidth = obj.size / 4;
                this.ctx.moveTo(obj.x - obj.size / 2, obj.y);
                this.ctx.lineTo(obj.x + obj.size / 2, obj.y);
                this.ctx.moveTo(obj.x, obj.y - obj.size / 2);
                this.ctx.lineTo(obj.x, obj.y + obj.size / 2);
                this.ctx.stroke();
                this.ctx.restore();
            },

            // End trial
            endTrial() {
                this.state.isRunning = false;
                this.unexpectedObject = null;

                // Calculate total crossings
                let totalCrossings = 0;
                this.objects.forEach(obj => {
                    totalCrossings += obj.crossings;
                });

                this.data.trials.crossings.push(totalCrossings);
                console.log("Trial", this.state.currentTrial + 1, "- Actual touches:", totalCrossings);

                this.showResponseInput();
            },

            // Show response input
            showResponseInput() {
                this.showScreen('responseScreen');
                document.getElementById('responsePrompt').textContent =
                    `In the box below, please enter the total number of times the circles touched either of the two horizontal lines.`;
                document.getElementById('countInput').value = '';
                document.getElementById('countInput').focus();
            },

            // Submit counting response
            submitResponse() {
                const count = parseInt(document.getElementById('countInput').value) || 0;
                this.data.trials.counts.push(count);

                const trialIndex = this.data.trials.counts.length - 1;
                const actual = this.data.trials.crossings[trialIndex];
                const percentError = Math.abs(count - actual) / actual * 100;
                const accuracy = Math.max(0, Math.min(100, 100 - percentError));
                this.data.trials.accuracy.push(parseFloat(accuracy.toFixed(2)));

                console.log("Count submitted:", count, "Actual:", actual, "Accuracy:", accuracy.toFixed(2) + "%");

                const trialType = this.state.trialSequence[this.state.currentTrial];

                if (trialType === 'critical' || trialType === 'divided') {
                    this.showNoticeQuestion();
                } else {
                    this.nextTrial();
                }
            },

            // Show notice question
            showNoticeQuestion() {
                this.showScreen('yesNoScreen');
                const trialType = this.state.trialSequence[this.state.currentTrial];

                if (trialType === 'critical') {
                    document.getElementById('yesNoQuestion').textContent =
                        "Did you notice anything extra during the last counting trial that wasn't there in the previous trials?";
                } else {
                    document.getElementById('yesNoQuestion').textContent =
                        "Did you notice an extra object on that trial?";
                }
            },

            // Submit yes/no response
            submitYesNo(answer) {
                const trialType = this.state.trialSequence[this.state.currentTrial];
                const responseIndex = trialType === 'critical' ? 0 : 1;
                this.data.responses.noticed[responseIndex] = answer;

                console.log("Noticed:", answer, "Trial type:", trialType);

                this.showShapeSelection();
            },

            // Show shape selection
            showShapeSelection() {
                this.showScreen('shapeScreen');
                document.querySelectorAll('#shapeSection .shape-choice').forEach(el => {
                    el.classList.remove('selected');
                });
                this.selectedShape = null;
            },

            // Select a shape
            selectShape(shape) {
                document.querySelectorAll('#shapeSection .shape-choice').forEach(el => {
                    el.classList.remove('selected');
                });
                event.currentTarget.classList.add('selected');
                this.selectedShape = shape;
            },

            // Submit shape choice
            submitShapeChoice() {
                if (!this.selectedShape) {
                    alert("Please select a shape");
                    return;
                }

                const trialType = this.state.trialSequence[this.state.currentTrial];
                const responseIndex = trialType === 'critical' ? 0 : 1;
                this.data.responses.shapeChoice[responseIndex] = this.selectedShape;

                console.log("Shape choice:", this.selectedShape);

                this.nextTrial();
            },

            // Move to next trial
            nextTrial() {
                this.state.currentTrial++;

                if (this.state.currentTrial < this.state.trialSequence.length) {
                    this.showInstructions();
                } else {
                    this.showPlaybackQuestion();
                }
            },

            // Show playback question
            showPlaybackQuestion() {
                const practiceAcc1 = this.data.trials.accuracy[0] || 0;
                const practiceAcc2 = this.data.trials.accuracy[1] || 0;
                this.data.practiceAccuracyAvg = parseFloat(((practiceAcc1 + practiceAcc2) / 2).toFixed(2));

                this.showScreen('playbackScreen');
                document.getElementById('playbackQuestion').textContent =
                    "Did the animation play smoothly, with no obvious lagging or freezing?";
            },

            // Submit playback response
            submitPlayback(answer) {
                this.data.runSmoothly = answer;
                console.log("Run smoothly:", answer);

                if (answer === 'No') {
                    this.showGlitchesScreen();
                } else {
                    this.showFinalScreen();
                }
            },

            // Show glitches description screen
            showGlitchesScreen() {
                this.showScreen('glitchesScreen');
                document.getElementById('glitchesInput').value = '';
            },

            // Submit glitches description
            submitGlitches() {
                this.data.glitchesDescription = document.getElementById('glitchesInput').value;
                console.log("Glitches description:", this.data.glitchesDescription);
                this.showFinalScreen();
            },

            // Show final screen
            showFinalScreen() {
                this.showScreen('finalScreen');
            },

            // Submit all data
            submitData() {
                this.timing.endTime = new Date();
                this.data.endTime = this.formatDate(this.timing.endTime);
                this.data.duration = Math.round((this.timing.endTime - this.timing.startTime) / 1000);

                const form = document.getElementById('task_data');
                form.study_name.value = this.data.studyName;
                form.subject_code.value = this.data.subjectCode;
                form.start_time.value = this.data.startTime;
                form.end_time.value = this.data.endTime;
                form.duration.value = this.data.duration;
                form.background_color.value = this.config.backgroundColor;
                form.attended_color.value = this.state.attendedColor;
                form.line_color.value = this.config.lineColor;
                form.top_line_position.value = this.config.topLinePosition;
                form.bottom_line_position.value = this.config.bottomLinePosition;
                form.bounce_angle_variation.value = this.config.bounceAngleVariation;
                form.min_angle_from_wall.value = this.config.minAngleFromWall;
                form.perturbation_interval_min.value = this.config.perturbationIntervalMin;
                form.perturbation_interval_max.value = this.config.perturbationIntervalMax;
                form.perturbation_amount.value = this.config.perturbationAmount;
                form.speed_min.value = this.config.speedMin;
                form.speed_max.value = this.config.speedMax;
                form.unexpected_object_speed.value = this.config.unexpectedObjectSpeed;
                form.unexpected_object_color.value = this.data.unexpectedObjectColor || '';
                form.unexpected_object_shape.value = this.data.unexpectedObjectShape || '';
                form.unexpected_object_direction.value = this.data.unexpectedObjectDirection || '';

                // Trial 1 (Practice 1)
                form.trial1_crossings.value = this.data.trials.crossings[0] || '';
                form.trial1_count.value = this.data.trials.counts[0] || '';
                form.trial1_accuracy.value = this.data.trials.accuracy[0] || '';

                // Trial 2 (Practice 2)
                form.trial2_crossings.value = this.data.trials.crossings[1] || '';
                form.trial2_count.value = this.data.trials.counts[1] || '';
                form.trial2_accuracy.value = this.data.trials.accuracy[1] || '';

                // Trial 3 (Critical)
                form.trial3_crossings.value = this.data.trials.crossings[2] || '';
                form.trial3_count.value = this.data.trials.counts[2] || '';
                form.trial3_accuracy.value = this.data.trials.accuracy[2] || '';
                form.trial3_noticed.value = this.data.responses.noticed[0] || '';
                form.trial3_shape_choice.value = this.data.responses.shapeChoice[0] || '';

                // Trial 4 (Divided)
                form.trial4_crossings.value = this.data.trials.crossings[3] || '';
                form.trial4_count.value = this.data.trials.counts[3] || '';
                form.trial4_accuracy.value = this.data.trials.accuracy[3] || '';
                form.trial4_noticed.value = this.data.responses.noticed[1] || '';
                form.trial4_shape_choice.value = this.data.responses.shapeChoice[1] || '';

                // Accuracy summary
                form.practice_accuracy_avg.value = this.data.practiceAccuracyAvg || '';

                // Playback
                form.run_smoothly.value = this.data.runSmoothly || '';
                form.glitches_description.value = this.data.glitchesDescription || '';

                // Log all data
                console.log("=== FINAL DATA ===");
                console.log("Study name:", this.data.studyName);
                console.log("Subject:", this.data.subjectCode);
                console.log("Duration:", this.data.duration, "seconds");
                console.log("Attended color:", this.state.attendedColor);
                console.log("Line positions: top =", this.config.topLinePosition, ", bottom =", this.config.bottomLinePosition);
                console.log("Crossings:", this.data.trials.crossings);
                console.log("Counts:", this.data.trials.counts);
                console.log("Accuracy:", this.data.trials.accuracy);
                console.log("Practice Avg:", this.data.practiceAccuracyAvg);
                console.log("UO Color:", this.data.unexpectedObjectColor);
                console.log("UO Shape:", this.data.unexpectedObjectShape);
                console.log("UO Direction:", this.data.unexpectedObjectDirection);
                console.log("Noticed:", this.data.responses.noticed);
                console.log("Shape Choice:", this.data.responses.shapeChoice);
                console.log("==================");

                // Create data object for submission
                const formData = new FormData(form);
                const dataObject = {};
                formData.forEach((value, key) => {
                    dataObject[key] = value;
                });

                const json = JSON.stringify(dataObject);
                console.log("JSON being sent:", json);

                // Send data via XMLHttpRequest
                const xhr = new XMLHttpRequest();
                xhr.open("POST", "data.php", true);
                xhr.setRequestHeader("Content-Type", "application/json");
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        console.log("Server response:", xhr.responseText);
                        if (xhr.status === 200) {
                            window.location.href = 'https://app.prolific.com/submissions/complete?cc=C1QBLCRQ';
                            console.log("Data submitted successfully.");
                        } else {
                            console.error("Error submitting data");
                        }
                    }
                };
                xhr.send(json);
            }
        };

        // ============================================================
        // INITIALIZATION
        // ============================================================
        window.onload = function() {
            console.log("Page loaded - Experiment ready!");
            experiment.init();
            experiment.showInstructions();
        };
    </script>
</body>
</html>